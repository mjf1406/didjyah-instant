/** @format */

"use client";

import React, { createContext, useContext, useState, useCallback } from "react";
import { toast } from "sonner";
import { db } from "@/lib/db";
import { id } from "@instantdb/react";

type ActionType = "create" | "update" | "delete";

type UndoableAction = {
    type: ActionType;
    entityType: "todos" | "didjyahs" | "didjyahRecords";
    entityId: string;
    previousData?: Record<string, unknown>; // For update/delete - store previous state
    newData?: Record<string, unknown>; // For create/update - store new state
    links?: Record<string, string>; // Store link information
    message: string; // Toast message
};

type UndoContextType = {
    registerAction: (action: UndoableAction) => void;
    undoLastAction: () => Promise<void>;
    hasUndoableAction: boolean;
};

const UndoContext = createContext<UndoContextType | undefined>(undefined);

export function UndoProvider({ children }: { children: React.ReactNode }) {
    const [lastAction, setLastAction] = useState<UndoableAction | null>(null);
    const [toastId, setToastId] = useState<string | number | null>(null);

    const undoAction = useCallback(async (action: UndoableAction) => {
        try {
            switch (action.type) {
                case "create":
                    // Undo create = delete
                    await db.transact(
                        db.tx[action.entityType][action.entityId].delete()
                    );
                    toast.success("Action undone");
                    break;

                case "delete":
                    // Undo delete = recreate with previous data
                    if (action.previousData && action.links) {
                        let tx = db.tx[action.entityType][action.entityId]
                            .update(action.previousData);
                        
                        // Restore links by chaining
                        Object.entries(action.links).forEach(([key, value]) => {
                            tx = tx.link({ [key]: value });
                        });
                        
                        await db.transact(tx);
                    }
                    toast.success("Action undone");
                    break;

                case "update":
                    // Undo update = restore previous data
                    if (action.previousData) {
                        await db.transact(
                            db.tx[action.entityType][action.entityId].update(
                                action.previousData
                            )
                        );
                    }
                    toast.success("Action undone");
                    break;
            }
        } catch (error) {
            const message =
                error instanceof Error
                    ? error.message
                    : "Failed to undo action";
            toast.error(message);
        }
    }, []);

    const registerAction = useCallback((action: UndoableAction) => {
        setLastAction(action);

        // Dismiss previous toast if exists
        if (toastId !== null) {
            toast.dismiss(toastId);
        }

        // Show new toast with undo button
        const newToastId = toast.success(action.message, {
            action: {
                label: "Undo",
                onClick: async () => {
                    await undoAction(action);
                    setLastAction(null);
                    setToastId(null);
                },
            },
            duration: 5000,
        });

        setToastId(newToastId);

        // Clear action after toast expires
        setTimeout(() => {
            setLastAction(null);
            setToastId(null);
        }, 5000);
    }, [toastId, undoAction]);

    const undoLastAction = useCallback(async () => {
        if (lastAction) {
            await undoAction(lastAction);
            setLastAction(null);
            if (toastId !== null) {
                toast.dismiss(toastId);
                setToastId(null);
            }
        }
    }, [lastAction, toastId, undoAction]);

    return (
        <UndoContext.Provider
            value={{
                registerAction,
                undoLastAction,
                hasUndoableAction: lastAction !== null,
            }}
        >
            {children}
        </UndoContext.Provider>
    );
}

export function useUndo() {
    const context = useContext(UndoContext);
    if (context === undefined) {
        throw new Error("useUndo must be used within an UndoProvider");
    }
    return context;
}

// Helper function to get current entity data for undo
export async function getEntityData(
    entityType: "todos" | "didjyahs" | "didjyahRecords",
    entityId: string
): Promise<Record<string, unknown> | null> {
    try {
        let data: any;
        
        // Handle each entity type separately for proper TypeScript typing
        switch (entityType) {
            case "todos":
                ({ data } = await db.queryOnce({
                    todos: {
                        $: { where: { id: entityId } },
                    },
                }));
                break;
            case "didjyahs":
                ({ data } = await db.queryOnce({
                    didjyahs: {
                        $: { where: { id: entityId } },
                    },
                }));
                break;
            case "didjyahRecords":
                ({ data } = await db.queryOnce({
                    didjyahRecords: {
                        $: { where: { id: entityId } },
                    },
                }));
                break;
        }
        
        const entity = data?.[entityType]?.[0];
        if (!entity) return null;

        // Extract only the data fields (exclude id and links)
        const { id: _, ...dataFields } = entity;
        return dataFields as Record<string, unknown>;
    } catch (error) {
        console.error("Error fetching entity data:", error);
        return null;
    }
}

